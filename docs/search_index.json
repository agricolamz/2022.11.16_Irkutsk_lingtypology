[["intro.html", "Введение в lingtypology 1 Введение в R 1.1 Установка R и RStudio 1.2 Полезные ссылки 1.3 Rstudio 1.4 Введение в R 1.5 Типы данных 1.6 Вектор 1.7 Датафрейм", " Введение в lingtypology Г. Мороз 1 Введение в R 1.1 Установка R и RStudio Нам понадобятся: зарегестрироваться на https://rstudio.cloud/ Часто можно увидеть или услышать, что R — язык программирования для “статистической обработки данных”. Изначально это, конечно, было правдой, но уже давно R — это полноценный язык программирования, который при помощи своих пакетов позволяет решать огромный спектр задач. В данной книге используется следующая версия R: ## [1] &quot;R version 4.2.2 Patched (2022-11-10 r83330)&quot; 1.2 Полезные ссылки В интернете легко найти документацию и туториалы по самым разным вопросам в R, так что главный залог успеха — грамотно пользоваться поисковиком, и лучше на английском языке. книга (Wickham and Grolemund 2016) stackoverflow — сервис, где достаточно быстро отвечают на любые вопросы (не обязательно по R) RStudio community — быстро отвечают на вопросы, связанные с R русский stackoverflow R-bloggers — сайт, где собираются новинки, связанные с R чат, где можно спрашивать про R на русском (но почитайте правила чата, перед тем как спрашивать) чат по визуализации данных, чат датажурналистов канал про визуализацию, дата-блог “Новой газеты”, … 1.3 Rstudio Когда вы откроете RStudio первый раз, вы увидите три панели: консоль, окружение и историю, а также панель для всего остального. Если ткнуть в консоли на значок уменьшения, то можно открыть дополнительную панель, где можно писать скрипт. Существуют разные типы пользователей: одни любят работать в консоли (на картинке это 2 — R Console), другие предпочитают скрипты (1 — Code Editor). Консоль позволяет использовать интерактивный режим команда-ответ, а скрипт является по сути текстовым документом, фрагменты которого можно для отладки запускать в консоли. 3 — Workspace and History: Здесь можно увидеть переменные. Это поле будет автоматически обновляться по мере того, как Вы будете запускать строчки кода и создавать новые переменные. Еще там есть вкладка с историей последних команд, которые были запущены. 4 — Plots and files: Здесь есть очень много всего. Во-первых, небольшой файловый менеджер, во-вторых, там будут появляться графики, когда вы будете их рисовать. Там же есть вкладка с вашими пакетами (Packages) и Help по функциям. Но об этом потом. 1.4 Введение в R 1.4.1 R как калькулятор Ой-ей, консоль, скрипт че-то все непонятно. Давайте начнем с самого простого и попробуем использовать R как простой калькулятор. +, -, *, /, ^ (степень), () и т.д. Просто запускайте в консоли пока не надоест: 40+2 ## [1] 42 3-2 ## [1] 1 5*6 ## [1] 30 99/9 ## [1] 11 2^3 ## [1] 8 (2+2)*2 ## [1] 8 Ничего сложного, верно? Вводим выражение и получаем результат. Порядок выполнения арифметических операций как в математике, так что не забывайте про скобочки. Если Вы не уверены в том, какие операции имеют приоритет, то используйте скобочки, чтобы точно обозначить, в каком порядке нужно производить операции. Важно отметить, что R может служить лишь как калкулятор. Можно узнать, что \\(\\cos(\\frac{\\pi}{2})\\) приблизительно равно 0.9659258, но вы никогда не узнаете, что \\(\\cos(\\frac{\\pi}{2})\\) также равно \\(\\sqrt{\\frac{1+\\frac{\\sqrt{3}}{2}}{2}}\\). Но при этом какие-то рутинные операции, с которыми вы, возможно, сталкивались (дифернцирование, интегрирование, нахождение корней полинома и др.), R делает с легкостью. 1.4.2 Функции Давайте теперь извлечем корень из какого-нибудь числа. В принципе, тем, кто помнит школьный курс математики, возведения в степень вполне достаточно: 16^0.5 ## [1] 4 Ну а если нет, то можете воспользоваться специальной функцией: это обычно какие-то буквенные символы с круглыми скобками сразу после названия функции. Мы подаем на вход (внутрь скобочек) какие-то данные, внутри этих функций происходят какие-то вычисления, которые выдают в ответ какие-то другие данные (или же функция записывает файл, рисует график и т.д.). Вот, например, функция для корня: sqrt(16) ## [1] 4 R — case-sensitive язык, т.е. регистр важен. SQRT(16) не будет работать. А вот так выглядит функция логарифма: log(8) ## [1] 2.079442 Так, вроде бы все нормально, но… Если Вы еще что-то помните из школьной математики, то должны понимать, что что-то здесь не так. Здесь не хватает основания логарифма! Логарифм — показатель степени, в которую надо возвести число, называемое основанием, чтобы получить данное число. То есть у логарифма 8 по основанию 2 будет значение 3: \\(\\log_2 8 = 3\\) То есть если возвести 2 в степень 3 у нас будет 8: \\(2^3 = 8\\) Только наша функция считает все как-то не так. Чтобы понять, что происходит, нам нужно залезть в хэлп этой функции: ?log Справа внизу в RStudio появится вот такое окно: Действительно, у этой функции есть еще аргумент base =. По дефолту он равен числу Эйлера (2.7182818…), т.е. функция считает натуральный логарифм. В большинстве функций R есть какой-то основной инпут — данные в том или ином формате, а есть и дополнительные параметры, которые можно прописывать вручную, если параметры по умолчанию нас не устраивают. log(x = 8, base = 2) ## [1] 3 …или просто (если Вы уверены в порядке аргументов): log(8,2) ## [1] 3 Более того, Вы можете использовать оутпут одних функций как инпут для других: log(8, sqrt(4)) ## [1] 3 Если эксплицитно писать имена аргументов, то их порядок в функции не важен: log(base = 2, x = 8) ## [1] 3 А еще можно недописывать имена аргументов, если они не совпадают с другими: log(b = 2, x = 8) ## [1] 3 1.4.3 Переменные Важная штука в программировании на практически любом языке — возможность сохранять значения в переменных. В R это обычно делается с помощью вот этих символов: &lt;- (но можно использовать и обычное =, хотя это не очень принято). Для этого есть удобное сочетание клавиш: нажмите одновременно Alt - (или option - на Маке). a &lt;- 2 a ## [1] 2 После присвоения переменная появляется во вкладке Environment в RStudio: Можно использовать переменные в функциях и просто вычислениях: b &lt;- a^a+a*a b ## [1] 8 log(b,a) ## [1] 3 1.5 Типы данных Теперь нам нужно ознакомиться с двумя другими важными типами данных в R: character: строки символов. Они должны выделяться кавычками. Можно использовать как \", так и ' (что удобно, когда строчка внутри уже содержит какие-то кавычки). s &lt;- &quot;Всем привет!&quot; s ## [1] &quot;Всем привет!&quot; logical: просто TRUE или FALSE. t1 &lt;- TRUE f1 &lt;- FALSE t1 ## [1] TRUE f1 ## [1] FALSE 1.6 Вектор Вектор (или atomic vector или atomic) — это набор (столбик) чисел в определенном порядке. На самом деле, мы уже работали с векторами в R, но, возможно, Вы об этом даже не догадывались. Дело в том, что в R нет как таковых “значений”, есть вектора длиной 1. Чтобы создать вектор из нескольких значений, нужно воспользоваться функцией c(): c(4,8,15,16,23,42) ## [1] 4 8 15 16 23 42 c(&quot;Хэй&quot;, &quot;Хэй&quot;, &quot;Ха&quot;) ## [1] &quot;Хэй&quot; &quot;Хэй&quot; &quot;Ха&quot; Одна из самых мерзких и раздражающих причин ошибок в коде — это использование с из кириллицы вместо c из латиницы. Видите разницу? И я не вижу. А R видит. И об этом сообщает: с(3, 4, 5) ## Error in с(3, 4, 5): could not find function &quot;с&quot; Для создания числовых векторов есть удобный оператор : 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 5:-3 ## [1] 5 4 3 2 1 0 -1 -2 -3 Этот оператор создает вектор от первого числа до второго с шагом 1. Вы не представляете, как часто эта штука нам пригодится… Если же нужно сделать вектор с другим шагом, то есть функция seq(): seq(10,100, by = 10) ## [1] 10 20 30 40 50 60 70 80 90 100 Кроме того, можно задавать не шаг, а длину вектора. Тогда шаг функция seq() посчитает сама: seq(1,13, length.out = 4) ## [1] 1 5 9 13 Другая функция — rep() — позволяет создавать вектора с повторяющимися значениями. Первый аргумент — значение, которое нужно повторять, а второй аргумент — сколько раз повторять. rep(1, 5) ## [1] 1 1 1 1 1 И первый, и второй аргумент могут быть векторами! rep(1:3, 3) ## [1] 1 2 3 1 2 3 1 2 3 rep(1:3, 1:3) ## [1] 1 2 2 3 3 3 Еще можно объединять вектора (что мы, по сути, и делали, просто с векторами длиной 1): v1 &lt;- c(&quot;Hey&quot;, &quot;Ho&quot;) v2 &lt;- c(&quot;Let&#39;s&quot;, &quot;Go!&quot;) c(v1,v2) ## [1] &quot;Hey&quot; &quot;Ho&quot; &quot;Let&#39;s&quot; &quot;Go!&quot; 1.6.1 Индексирование векторов Задача, которую Вам придется решать каждые пять минут работы в R - как выбрать из вектора (или же списка, матрицы и датафрейма) какую-то его часть. Для этого используются квадратные скобочки [] (не круглые - они для функций!). Самое простое - индексировать по номеру индекса, т.е. порядку значения в векторе. n &lt;- 1:10 n[1] ## [1] 1 n[10] ## [1] 10 С помощью индексирования можно не только вытаскивать имеющиеся значения в векторе, но и присваивать им новые: Конечно, можно использовать целые векторы для индексирования: n[4:7] ## [1] 4 5 6 7 n[10:1] ## [1] 10 9 8 7 6 5 4 3 2 1 Индексирование с минусом выдаст вам все значения вектора кроме выбранных: n[-1] ## [1] 2 3 4 5 6 7 8 9 10 n[-c(4, 5)] ## [1] 1 2 3 6 7 8 9 10 Более того, можно использовать логический вектор для индексирования. В этом случае нужен логический вектор такой же длины: n[c(TRUE,FALSE,TRUE,FALSE,TRUE,FALSE,TRUE,FALSE,TRUE,FALSE)] ## [1] 1 3 5 7 9 Ну а если они не равны, то тут будет снова работать правило ресайклинга! n[c(TRUE,FALSE)] #то же самое - recycling rule! ## [1] 1 3 5 7 9 Есть еще один способ индексирования векторов, но он несколько более редкий: индексирование по имени. Дело в том, что для значений векторов можно (но не обязательно) присваивать имена: my_named_vector &lt;- c(first = 1, second = 2, third = 3) my_named_vector[&#39;first&#39;] ## first ## 1 А еще можно “вытаскивать” имена из вектора с помощью функции names() и присваивать таким образом новые. d &lt;- 1:4 names(d) &lt;- letters[1:4] d[&quot;a&quot;] ## a ## 1 letters - это “зашитая” в R константа - вектор букв от a до z. Иногда это очень удобно! Кроме того, есть константа LETTERS - то же самое, но заглавными буквами. А еще есть названия месяцев на английском и числовая константа pi. Теперь посчитаем среднее вектора n: mean(n) ## [1] 5.5 А как вытащить все значения, которые больше среднего? Сначала получим логический вектор — какие значения больше среднего: larger &lt;- n &gt; mean(n) larger ## [1] FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE А теперь используем его для индексирования вектора n: n[larger] ## [1] 6 7 8 9 10 Можно все это сделать в одну строчку: n[n&gt;mean(n)] ## [1] 6 7 8 9 10 1.7 Датафрейм Табличные данные хранятся в R в виде датафреймов. Важное ограничение – в одном столбце должны быть данные одного типа. name &lt;- c(&quot;Ivan&quot;, &quot;Eugeny&quot;, &quot;Lena&quot;, &quot;Misha&quot;, &quot;Sasha&quot;) age &lt;- c(26, 34, 23, 27, 26) student &lt;- c(FALSE, FALSE, TRUE, TRUE, TRUE) df &lt;- data.frame(name, age, student) df Чтобы вызвать какой-то из векторов датафрейма нужно использовать знак доллара df$age ## [1] 26 34 23 27 26 К нему можно обращаться обычным образом через квадратные скобки df$age[2:5] ## [1] 34 23 27 26 Кроме того можно обращаться через запятую к строчкам (до запятой) и к столбцам (после запятой): df[3:5, 2:3] А еще можно использовать названия колонок внутри квадратных скобок: df[1:2,&quot;age&quot;] ## [1] 26 34 References "],["что-такое-lingtypology.html", "2 Что такое lingtypology? 2.1 Установка пакета 2.2 Функции для базы Glottolog 2.3 Создание карт 2.4 API 2.5 … а вообще смотрите мануал", " 2 Что такое lingtypology? простое средство для создания статических и динамических карт API для разных лингвистических баз данных (Glottolog, WALS, PHOIBLe, AUTOTYP и другие) 2.1 Установка пакета Пакет можно скачать из CRAN: install.packages(&quot;lingtypology&quot;) … или из GitHub: # install.packages(&quot;devtools&quot;) # devtools::install_github(&quot;ropensci/lingtypology&quot;) Если появляются какие-то проблемы с зависимостями, то можно попробовать установить более старую версию: devtools::install_version(&quot;lingtypology&quot;, version = &quot;1.0.12&quot;) Загружаем библиотеку: library(lingtypology) 2.2 Функции для базы Glottolog Пакте основан на базе данных Glottolog database (v. 2.7), так что в lingtypology существует несколько функций для более простого . 2.2.1 Синтаксис Большинство функций в lingtypology имеют стандартный синтаксис: то, что надо.то, что есть. aff.lang() — аффилиация по языку area.lang() — макро регион по языку country.lang() — страна по языку iso.lang() — ISO 639-3 код по языку gltc.lang() — glottocode (идентификатор языка в базе данных Glottolog) по языку lat.lang() — широта по языку long.lang() — долгота по языку lang.aff() — языки по аффилиации lang.iso() — язык по ISO 639-3 коду lang.gltc() — язык по glottocode Можно конвертировать glottocod в ISO 639-3 и обратно: gltc.iso() — get glottocode by ISO 639-3 code iso.gltc() — get ISO 639-3 code by glottocode В базе данных Glottolog database (v. 4.6) достаточно много всего. Вот какие переменные есть в базе: names(glottolog) [1] &quot;glottocode&quot; &quot;language&quot; &quot;iso&quot; [4] &quot;level&quot; &quot;area&quot; &quot;latitude&quot; [7] &quot;longitude&quot; &quot;countries&quot; &quot;affiliation&quot; [10] &quot;subclassification&quot; 2.2.2 Как использовать основные функции? Все функции могут брать в качестве аргумента: обычную строку iso.lang(&quot;Adyghe&quot;) Adyghe &quot;ady&quot; lang.iso(&quot;ady&quot;) ady &quot;Adyghe&quot; country.lang(&quot;Adyghe&quot;) Adyghe &quot;Israel;Jordan;Russia;Turkey&quot; lang.aff(&quot;Daghestanian&quot;) [1] &quot;Bats&quot; &quot;Ingush&quot; &quot;Chechen&quot; [4] &quot;Lak&quot; &quot;Khinalug&quot; &quot;Archi&quot; [7] &quot;Udi&quot; &quot;Aghwan&quot; &quot;Tabasaran&quot; [10] &quot;Aghul&quot; &quot;Lezgian&quot; &quot;Rutul&quot; [13] &quot;Tsakhur&quot; &quot;Kryz&quot; &quot;Budukh&quot; [16] &quot;Avar&quot; &quot;Akhvakh&quot; &quot;Andi&quot; [19] &quot;Chamalal&quot; &quot;Karata-Tukita&quot; &quot;Tindi&quot; [22] &quot;Bagvalal&quot; &quot;Botlikh&quot; &quot;Godoberi&quot; [25] &quot;Tsez&quot; &quot;Hinuq&quot; &quot;Khwarshi-Inkhoqwari&quot; [28] &quot;Hunzib&quot; &quot;Bezhta&quot; &quot;North-Central Dargwa&quot; [31] &quot;Kubachi&quot; &quot;Chirag&quot; &quot;Southwestern Dargwa&quot; [34] &quot;Kajtak&quot; вектор строк area.lang(c(&quot;Adyghe&quot;, &quot;Aduge&quot;)) Adyghe Aduge &quot;Eurasia&quot; &quot;Africa&quot; lang &lt;- c(&quot;Adyghe&quot;, &quot;Russian&quot;) aff.lang(lang) Adyghe &quot;Abkhaz-Adyge, Circassian&quot; Russian &quot;Indo-European, Classical Indo-European, Balto-Slavic, Slavic, East Slavic&quot; другие функции iso.lang(lang.aff(&quot;Circassian&quot;)) Adyghe Kabardian &quot;ady&quot; &quot;kbd&quot; Поведение большинства функций достаточно предсказуемо, но функция country.lang имеет некоторые особенности. По умолчанию она берет вектор языков и возвращает вектор стран. Однако если добавить аргумент intersection = TRUE, то функция вернет вектор стран, где говорят на всех языках из запроса. country.lang(c(&quot;Udi&quot;, &quot;Laz&quot;)) Udi Laz &quot;Azerbaijan;Georgia;Russia&quot; &quot;Georgia;Turkey&quot; 2.2.3 Спеллчекер: смотрите в сообщения об ошибках! Существуют функции, которые принимают страны в качестве входа. К сожалению, некоторые страны имеют альтернативные названия и стандартные сокращения. Так что, для того, чтобы пользователям не пришлось думать, как правильно Ivory Coast или Cote d’Ivoire, все официальные сокращения и названия хранятся в базе данных: lang.country(&quot;Cape Verde&quot;) $`Cape Verde` [1] &quot;Kabuverdianu&quot; head(lang.country(&quot;US&quot;, list = FALSE)) [1] &quot;Siuslaw&quot; &quot;Salinan&quot; &quot;Coahuilteco&quot; &quot;Yuchi&quot; [5] &quot;Takelma&quot; &quot;Klamath-Modoc&quot; Все функции, которые принимают вектор языков на вход, содержат в себе спеллчекер, который предложит варианты, если язык не найдется в базе данных: aff.lang(&quot;Adyge&quot;) Warning: Language Adyge is absent in our version of the Glottolog database. Did you mean Adyghe, Aduge, Abkhaz-Adyge? Adyge NA 2.2.4 Кельтские языки Сколько кельтских языков в базе? 2.2.5 Австронезийские языки Сколько австронезийских языков в базе? 2.3 Создание карт 2.3.1 Базовая функция map.feature(c(&quot;Adyghe&quot;, &quot;Kabardian&quot;, &quot;Polish&quot;, &quot;Russian&quot;, &quot;Bulgarian&quot;)) 2.3.2 Добавляем признаки Создаем датафрейм: df &lt;- data.frame(language = c(&quot;Adyghe&quot;, &quot;Kabardian&quot;, &quot;Polish&quot;, &quot;Russian&quot;, &quot;Bulgarian&quot;), features = c(&quot;polysynthetic&quot;, &quot;polysynthetic&quot;, &quot;fusional&quot;, &quot;fusional&quot;, &quot;fusional&quot;)) df Рисуем карту: map.feature(languages = df$language, features = df$features) Существует несколько типов переменных в R и map.feature работает по-разному в зависимости от типа переменных. Я воспользуюсь встроенным датасетом phonological_profiles который содержит 19 языков из базы данных UPSyD. В этом датасете семь переменных, в том числе категориальную переменную ejectives, которая показывает, есть ли в языке абруптивные звуки, и числовые переменные consonants and vowels, которые содержат информацию о количестве согласных и гласных в языке. map.feature(languages = phonological_profiles$language, features = phonological_profiles$ejectives) # categorical map.feature(languages = phonological_profiles$language, features = phonological_profiles$consonants) # numeric Карты можно показывать двумя способами: с Атлантическим и Тихим океанами в середине. Чобы поменять дефолтный вариант с Тихим океаном нужно поменять аргумент map.orientation: map.feature(languages = phonological_profiles$language, features = phonological_profiles$consonants, map.orientation = &quot;Atlantic&quot;) 2.3.3 Подписи К точкам можно добавлять подписи, используя аргумент label. map.feature(languages = df$language, features = df$features, label = df$language) Существует несколько дополнительных аргументов: label.fsize, label.position и label.hide. map.feature(languages = df$language, features = df$features, label = df$language, label.fsize = 20, label.position = &quot;left&quot;, label.hide = FALSE) 2.3.4 Task 3.1 Создайте карту с чукотским, французским, кана и нии и добавьте подписи, которые не исчезают: 2.3.5 Task 3.2 Создайте карту с бодскими языками и добавьте миникарту, используя аргумент minimap = TRUE: 2.4 API lingtypology позволяет скачать данные из других типологических баз. World Atlas of Language Structures AUTOTYP PHOIBLE Affix Borrowing database South American Indigenous Language Structures Austronesian Basic Vocabulary Database UraLex df &lt;- wals.feature(c(&quot;1a&quot;, &quot;20a&quot;)) head(df) map.feature(df$language, features = df$`1a`, latitude = df$latitude, longitude = df$longitude, label = df$language, title = &quot;Consonant Inventories&quot;) 2.5 … а вообще смотрите мануал "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
